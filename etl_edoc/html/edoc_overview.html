<! Generated by eDoc on Wed Oct 15 15:45:21 2014

<HTML>
<HEAD>
<script src="edoc_js.js"></script>
</HEAD>
<BODY>

<!-- ========== START OF TOOLBAR ========== -->

<table border=1 cellpadding=2 width=100%>
<tr>
<td bgcolor=darkblue><font color=white><b>Overview</b></font></td>
<td><b>Package</b></td>
<td><b>Struct</b></td>
<td><a href="edoc_tree.html"><b>Tree</b></a></td>
<td><a href="edoc_index.html"><b>Index</b></a></td>
</tr>
</table>

<!-- ========== END OF TOOLBAR ========== -->

<hr>
<center><h2>eDoc Report</h2></center><br>
eDoc report was created on <b>Wed Oct 15 15:45:21 2014</b><br>
<br>
<NOSCRIPT><font color=red><p>Source Browse demands JavaScript .Please enable JavaScript</font></p></NOSCRIPT>
<br>
<a name="Structs_summary"></a>
<table border=1 align=top width=100%>
<tr>
<td colspan=3 bgcolor=#CCCCFF>
<h2>Structs Summary</h2>
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____container__of__dummy______type__.html" target=mainFrame>container of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Abstract ordered container template. <br> It declares an API, similar to API of regular list, which is implemented by specific containers.<br> It inherits from base_struct, this means that it's not generatable, and can't have temporal struct members.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____deque__of__dummy______type__.html" target=mainFrame>deque of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i>Implements deque by circular array based on regular list.<br>The point of this container is that head modification operations like add0/push0/pop0 in O(1),<br>while for regular list they are O(N) operations. The price is that most regular operations <br>are a little more expensive, though asymptotically the same.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____deque_iterator__of__dummy______type__.html" target=mainFrame>deque_iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Iterator implementation for deque</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____iterator__of__dummy______type__.html" target=mainFrame>iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i>Abstract iterator for containers.<br>It declares iterator API implemented by iterators of specific containers.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____keyed_multi_set__of__dummy______type__.html" target=mainFrame>keyed_multi_set of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Implements keyed_multi_set, based on regular list and keyed list of indices per key. <br> Similar to regular "list (key:it) of <type>". (A data structure similar to "list (key:<field>) of <type>"<br> will be implemented as keyed_multi_map.) The main difference is that in case that there are multiple <br> equal key, behaviour is well defined: key operations return the last known index, and if the last <br>is removed, previous known is found, and so on, in stack fasion.<br> There is some significan memory overhead related to that, which can be minimized by enhancing the mechanism <br> and plugging in a pool of klist_node. Some CPU overhead also exists, but asymptotically it's just as good as<br> keyed list.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____keyed_multi_set_iterator__of__dummy______type__.html" target=mainFrame>keyed_multi_set_iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Iterator implementation for keyed_multi_set</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____keyed_set__of__dummy______type__.html" target=mainFrame>keyed_set of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Implements keyed_set, based on regular "list (key:it) of <type>". (A data structure similar to <br> "list (key:<field>) of <type>" will be implemented as keyed_map.) The difference is that the methods <br> that modify the contents, have checks to guarantee the consistency, first of all against inserting several equal keys.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____keyed_set_iterator__of__dummy______type__.html" target=mainFrame>keyed_set_iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Iterator implementation for keyed_set</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____linked_list__of__dummy______type__.html" target=mainFrame>linked_list of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i>Implement linked_list as a generic data structure. Good for O(1) changes of head, and using iterator - at any point.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____linked_list_iterator__of__dummy______type__.html" target=mainFrame>linked_list_iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Iterator implementation for linked_list</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____vector__of__dummy______type__.html" target=mainFrame>vector of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Effectively is a wrapper for regular list. Can be extended by user for build-in functionality.</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
<a name=""></a>
<code><a href="edoc_struct_etl____vector_iterator__of__dummy______type__.html" target=mainFrame>vector_iterator of &lt;type&gt;</a></code>
</td>
<td>
<font size=-1><i> Iterator implementation for vector</i></font>
</td>
<td>
&nbsp;
</td>
</tr>
</table>
<br>
<hr>

<!-- ========== START OF TOOLBAR ========== -->

<table border=1 cellpadding=2 width=100%>
<tr>
<td bgcolor=darkblue><font color=white><b>Overview</b></font></td>
<td><b>Package</b></td>
<td><b>Struct</b></td>
<td><a href="edoc_tree.html"><b>Tree</b></a></td>
<td><a href="edoc_index.html"><b>Index</b></a></td>
</tr>
</table>

<!-- ========== END OF TOOLBAR ========== -->

</BODY>
</HTML>
